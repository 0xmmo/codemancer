{"version":3,"sources":["../src/index.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport fs from \"fs\";\nimport fetch from \"node-fetch\";\nimport { createParser } from \"eventsource-parser\";\nimport yargs from \"yargs/yargs\";\nimport { hideBin } from \"yargs/helpers\";\nimport chalk from \"chalk\";\nimport { exec } from \"child_process\";\n\nconst modifyInstruction = `You are a sophisticated, accurate, and modern AI programming assistant. Whenever you are prompted with a file to modify, you always return the complete code in a fenced code block ready to run without any placeholders and including the unchanged code.`;\nconst identifyPlaceholdersInstruction = `Below is the code output by an AI programming assistant. This code may contain one or multiple placeholders that the AI creates to be filled in by the user. Please identify and list all the placeholders in this code. Examples: \"Rest of the code remains the same...\" OR \"YOUR CODE HERE\" OR \"Existing function code ...\"`;\n\nlet OPENAI_API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY;\nif (!OPENAI_API_KEY) {\n  OPENAI_API_URL = \"https://api.codemancer.codes/v1/chat/completions\";\n  console.error(\n    chalk.red(\n      \"Warning: OPENAI_API_KEY not set. Using free codemancer OpenAI proxy, which is slower and rate limited.\"\n    )\n  );\n}\n\nasync function main() {\n  const argv = await configureCommandLineArguments();\n  const {\n    inputFilePaths,\n    outputFilePaths,\n    prompt,\n    modelName,\n    temperature,\n    verbosity,\n  } = argv;\n\n  const inputContents = inputFilePaths.map((path) => readInputFile(path));\n  const promptWithInput = constructPromptWithInput(\n    prompt,\n    inputFilePaths,\n    inputContents\n  );\n  if (verbosity > 2) {\n    console.log(chalk.cyan(promptWithInput));\n  }\n\n  const completion = await getLLMCompletion(\n    modifyInstruction,\n    promptWithInput,\n    modelName,\n    temperature\n  );\n\n  if (outputFilePaths.length > 0) {\n    const codeBlocks = await extractCodeBlocks(completion, modelName);\n\n    if (codeBlocks.length > 0) {\n      let cbidx = 0;\n      for (const { language, codeBlock } of codeBlocks) {\n        const outputFilePath = outputFilePaths[cbidx] || outputFilePaths[0];\n\n        if (verbosity > 1) {\n          console.log(chalk.white(\"Code block found:\"));\n          console.log(chalk.green(codeBlock));\n        }\n\n        const confirmed = await handleUserInput(\n          language,\n          verbosity,\n          language === \"bash\" ? \"the command line\" : outputFilePath\n        );\n\n        if (confirmed) {\n          const newPath = confirmed === true ? outputFilePath : confirmed;\n\n          if (language === \"bash\") {\n            await runTerminalCommand(codeBlock, verbosity);\n          } else {\n            writeCodeBlockToFile(newPath, codeBlock, verbosity);\n          }\n        } else {\n          if (verbosity > 0) {\n            console.log(chalk.white(\"Operation aborted by the user.\"));\n          }\n        }\n\n        cbidx++;\n      }\n    } else {\n      if (verbosity > 0) {\n        console.log(chalk.red(\"No code block found in the completion.\"));\n      }\n    }\n  }\n}\n\nasync function configureCommandLineArguments(): Promise<{\n  inputFilePaths: string[];\n  outputFilePaths: string[];\n  prompt: string;\n  modelName: string;\n  temperature: number;\n  verbosity: number;\n}> {\n  const args = await yargs(hideBin(process.argv))\n    .option(\"p\", {\n      alias: \"prompt\",\n      type: \"string\",\n      description: \"Prompt for LLM completion\",\n    })\n    .option(\"i\", {\n      alias: \"input\",\n      type: \"string\",\n      description: \"Input file paths, separated by commas\",\n    })\n    .option(\"o\", {\n      alias: \"output\",\n      type: \"string\",\n      description: \"Output file paths, separated by commas\",\n    })\n    .option(\"m\", {\n      alias: \"model\",\n      type: \"string\",\n      default: \"gpt-4\",\n      description: \"Model name\",\n    })\n    .option(\"t\", {\n      alias: \"temperature\",\n      type: \"number\",\n      default: 0,\n      description: \"Temperature (0-2)\",\n    })\n    .option(\"s\", {\n      alias: \"verbosity\",\n      type: \"number\",\n      default: 2,\n      description: \"Verbosity (0-3)\",\n    }).argv;\n\n  const maybeInputs = args._[0].toString();\n  const maybePrompt = args._.slice(1).join(\" \").toString();\n\n  const prompt = args.p || (maybePrompt ? maybePrompt : maybeInputs);\n\n  const inputsArg = args.i || maybePrompt ? maybeInputs : null;\n  const inputFilePaths = inputsArg ? inputsArg.split(\",\") : [];\n  const outputFilePaths = args.o ? args.o.split(\",\") : inputFilePaths;\n\n  if (!prompt) {\n    throw new Error(\"Prompt is required.\");\n  } else if (maybeInputs && !maybePrompt) {\n    console.warn(\"Received a single argument, assuming it is prompt\");\n  }\n\n  return {\n    inputFilePaths,\n    outputFilePaths,\n    prompt,\n    modelName: args.m,\n    temperature: args.t,\n    verbosity: args.s,\n  };\n}\n\nfunction readInputFile(inputFilePath: string): string {\n  return fs.readFileSync(inputFilePath, \"utf-8\") || \"\";\n}\n\nfunction constructPromptWithInput(\n  prompt: string,\n  inputFilePaths: string[],\n  inputContents: string[]\n): string {\n  let promptWithInput = prompt;\n\n  for (let i = 0; i < inputFilePaths.length; i++) {\n    promptWithInput += `\n\n### ${inputFilePaths[i]}:\n\\`\\`\\`\n${inputContents[i]}\n\\`\\`\\`\n`;\n  }\n\n  return promptWithInput;\n}\n\nasync function getLLMCompletion(\n  instruction: string,\n  prompt: string,\n  model: string,\n  temperature: number\n): Promise<string> {\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${OPENAI_API_KEY}`,\n  };\n\n  const body = constructRequestBody(instruction, prompt, model, temperature);\n\n  const response = await fetch(OPENAI_API_URL, {\n    headers,\n    method: \"POST\",\n    body,\n  });\n\n  return handleAPIResponse(response as any as Response);\n}\n\nfunction constructRequestBody(\n  instruction: string,\n  prompt: string,\n  model: string,\n  temperature: number\n): string {\n  return JSON.stringify({\n    model,\n    temperature,\n    messages: [\n      {\n        role: \"system\",\n        content: instruction,\n      },\n      {\n        role: \"user\",\n        content: prompt,\n      },\n    ],\n    stream: true,\n    n: 1,\n  });\n}\n\nasync function handleAPIResponse(response: Response): Promise<string> {\n  const decoder = new TextDecoder();\n\n  return new Promise(async (resolve, reject) => {\n    let completionText = \"\";\n\n    if (!response.ok) {\n      const responseBody = await response.text();\n      reject(\n        `API error: ${response.status} ${response.statusText}\\nResponse body: ${responseBody}`\n      );\n    }\n\n    const parser = createParser((event) => {\n      if (event.type !== \"event\") return;\n      if (event.data === \"[DONE]\") {\n        process.stdout.write(\"\\n\\n\");\n        resolve(completionText);\n        return;\n      }\n\n      try {\n        const json = JSON.parse(event.data);\n        if (json.choices[0].delta?.role) return;\n        const text = json.choices[0].delta?.content || \"\";\n        completionText += text;\n        process.stdout.write(chalk.magenta(text));\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n    const body = response.body as any;\n\n    body.on(\"readable\", () => {\n      let chunk;\n      while (null !== (chunk = body.read())) {\n        parser.feed(decoder.decode(chunk));\n      }\n    });\n\n    body.on(\"end\", () => {\n      resolve(completionText);\n    });\n\n    body.on(\"error\", (err: any) => {\n      // reject(err);\n      // return response so far despite error e.g. premature close\n      reject(completionText);\n    });\n  });\n}\n\nasync function extractCodeBlocks(\n  completion: string,\n  modelName: string\n): Promise<{ language: string; codeBlock: string }[]> {\n  const codeBlockRegex = /^```([a-z]*)?\\s^([\\s\\S]*?)^```/gm;\n  const matches = completion.matchAll(codeBlockRegex);\n  const codeBlocks: { language: string; codeBlock: string }[] = [];\n\n  if (matches) {\n    for (const match of matches) {\n      codeBlocks.push({ language: match[1], codeBlock: match[2] });\n    }\n  }\n\n  for (const block of codeBlocks) {\n    const placeholders = await getLLMCompletion(\n      identifyPlaceholdersInstruction,\n      block.codeBlock,\n      modelName,\n      0\n    );\n\n    console.log(chalk.white(`Placeholders found: ${placeholders}`));\n  }\n\n  return codeBlocks;\n}\n\nasync function handleUserInput(\n  language: string,\n  verbosity: number,\n  outputFilePath: string\n): Promise<boolean | string> {\n  return new Promise((resolve) => {\n    process.stdin.resume();\n\n    if (verbosity === 0) {\n      resolve(true);\n    }\n\n    process.stdout.write(\n      chalk.white(\n        `Do you want to write this ${chalk.yellow(\n          language || \"unspecified language\"\n        )} code block to ${chalk.yellow(\n          outputFilePath\n        )}? \\nyes (y) / skip (s) / enter output path (o): `\n      )\n    );\n\n    process.stdin.once(\"data\", async (data) => {\n      const answer = data.toString().trim().toLowerCase();\n      if (answer === \"yes\" || answer === \"y\") {\n        resolve(true);\n      } else if (answer === \"skip\" || answer === \"s\") {\n        resolve(false);\n      } else if (answer === \"enter output path\" || answer === \"o\") {\n        const newPath = await getOutputFilePath();\n        resolve(newPath);\n      } else {\n        resolve(false);\n      }\n    });\n  });\n}\n\nasync function writeCodeBlockToFile(\n  newPath: string,\n  codeBlock: string,\n  verbosity: number\n): Promise<void> {\n  try {\n    fs.writeFileSync(newPath, codeBlock, \"utf-8\");\n    if (verbosity > 0) {\n      console.log(chalk.white(`Code block written to ${newPath}`));\n    }\n  } catch (error: any) {\n    console.error(chalk.red(`Error writing to file: ${error.message}`));\n    const newPath = await getOutputFilePath();\n    fs.writeFileSync(newPath, codeBlock, \"utf-8\");\n    if (verbosity > 0) {\n      console.log(chalk.white(`Code block written to ${newPath}`));\n    }\n  }\n}\n\nasync function runTerminalCommand(\n  command: string,\n  verbosity: number\n): Promise<[string, string]> {\n  return new Promise((resolve, reject) => {\n    exec(command, (error, stdout, stderr) => {\n      if (error) {\n        process.stderr.write(\n          chalk.red(`Error running command: ${JSON.stringify(error.message)}`)\n        );\n        reject(error);\n        return;\n      }\n\n      if (stderr) {\n        process.stderr.write(\n          chalk.red(`Command stderr: ${JSON.stringify(stderr)}`)\n        );\n        reject(new Error(stderr));\n        return;\n      }\n\n      if (verbosity > 0) {\n        process.stdout.write(chalk.green(`Command stdout: ${stdout}`));\n      }\n\n      resolve([stdout, stderr]);\n    });\n  });\n}\n\nasync function getOutputFilePath(): Promise<string> {\n  return new Promise((resolve) => {\n    process.stdin.resume();\n    process.stdout.write(chalk.white(\"Enter the new output file path: \"));\n    process.stdin.once(\"data\", (data) => {\n      const newPath = data.toString().trim();\n      resolve(newPath);\n    });\n  });\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((err) => {\n    console.error(chalk.red(err));\n    process.exit(1);\n  });\n"],"mappings":"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","names":["chalk","yargs","fs","fetch","newPath"]}